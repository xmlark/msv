<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="Tahiti.xsl" ?>
<article>
<articleinfo>
	<releaseinfo>$Id$</releaseinfo>
	<title>Tahiti User's Guide</title>
	<editor>
		<surname>KAWAGUCHI</surname>
		<firstname>Kohsuke</firstname>
		<affiliation>
			<address>
				<email>kohsuke.kawaguchi@sun.com</email>
			</address>
		</affiliation>
	</editor>
	<copyright>
		<year>2001</year>
		<holder>Sun Microsystems</holder>
	</copyright>
	<legalnotice><para>
			Sun internal use only.
	</para></legalnotice>
	<abstract><para>
			This document describes the general usage of Tahiti.
	</para></abstract>
</articleinfo>
<section>
	<title>Getting Started</title>
	
	<para>
		First, you need a grammar. Tahiti supports various schema language,
		but let's assume you have "foo.rng" file as your grammar.
		Then the first thing you should do is to run the schema compiler.
	</para>
	<screen><![CDATA[>java -jar tahiti.jar foo.rng]]></screen>
	<para>
		Schema compiler will generate Java source codes to the current directory.
		If you want it to place those files to another directory, then you can use
		the <userinput>-d</userinput> option like this:
	</para>
	<screen><![CDATA[>java Compiler foo.rng -d ../../src]]></screen>
	
	<para>
		Although the compiler takes every effort to extract a meaningful mapping from the schema,
		often it falls short of your expectation.
		
		If that is the case, you can control the way
		the compiler maps schemas to Java classes 
		by annotating schema files.
	</para><para>
		The annotation depends on the schema language you use. Consult the documentation
		for your choice of the schema language.
	</para>
	<itemizedlist>
		<listitem><para><ulink url="RELAX NG Bind.html">
			RELAX NG annotation
		</ulink></para></listitem>
	</itemizedlist>
</section>


<section>
	<title>Using the generated classes</title>
	
	<para>
		This section describes how you can use the genrated Java classes to do what you want.
	</para><para>
		You should know two important operations involving the generated classes.
		One is <emphasis>marshalling</emphasis> and the other is
		<emphasis>unmarshalling</emphasis>
	</para>
	
	<section>
		<title>Unmarshalling</title>
		
		<para>
			Unmarshalling is the process that reads an XML document and creates the corresponding
			Java objects. The easiest way to do this is to do as follows:
		</para>
<programlisting><![CDATA[
import org.example.test.Grammar;

class Main {
  public static void main() {
    // specify URL
    MyClass o1 = Grammar.unmarshall("file://abc/def.xml");
    // specify org.xml.sax.InputSource
    MyClass o2 = Grammar.unmarshall(new InputSource(new FileInputStream(...)));
  }
]]></programlisting>
		<para>
			The above method will read the document from the specified location and returns
			the result.
		</para><para>
			<classname>org.example.test.Grammar</classname> is the name of
			the compiled grammar, which is generated by the schema compiler.
			You should replace it with appropriate class name.
		</para><para>
			There are severl other overloaded version of this method, which accepts
			various type of inputs like
			<classname>org.xml.sax.InputSource</classname> or
			<classname>java.io.InputStream</classname>.
		</para><para>
			Should any error happens during the process of unmarshalling, an exception
			is thrown. See javadoc for details.
		</para>
	</section>
	
	
	<section>
		<title>Marshalling</title>
		
		<para>
			Marshalling is the process that writes XML representation of the Java object model.
			The easiest way to do this is to use the <classname>MarshallerAPI</classname>
			class.
		</para>
<programlisting><![CDATA[
import org.example.test.Grammar;
import com.sun.tahiti.runtime.sm.MarshallerAPI;

class Main {
  public static void main() {
    // create an object model.
    MyClass o1 = new MyClass();
    
    // then do something with it.
    ...
    
    // marshall it to DOM,
    Document dom = MarshallerAPI.marshallToDOM(o1);
    // marshall it to a File,
    MarshallerAPI.marshall( o1, "test.xml" );
    // or marshall it to an OutputStream
    MarshallerAPI.marshall( o1, System.out );
  }
]]></programlisting>
		<para>
			This class lets you produce XML in many ways.
			There are handful of overloaded versions of the marshall method, each support
			different type of output.
		</para>
		<para>
			Unfortunately, the implementation of the marshaller is rather poor at this moment.
			Sometimes, the compiler fails to produce a marshaller for a grammar.
			If it fails, please let us know so that we invent a better algorithm.
			Also, there is a workaround. If the compiler fails to produce a marshaller,
			then you can derive that class and implement it by hand.
		</para>
	</section>
	
	
	<section>
		<title>Creating objects programatically</title>
		
		<para>
			Unmarshalling is not the only way to construct an object model.
			Instead, you can programatically create it from scratch, much like
			you can create a DOM tree from scratch by using the createXXX methods
			of a <classname>org.w3c.dom.Document</classname> object.
		</para>
	</section>
</section>
</article>
